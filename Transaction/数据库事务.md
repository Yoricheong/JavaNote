
## 数据库事务

#### 基本概念
> ACID

#### 事务类型
* 平面(Flat)事务
> 平面事务是由一系列的原子性的操作构成，这些操作一起组成了单个工作单元。
    
* 嵌入式(Nested)事务。
> 嵌入式事务容许将原子性的工作单元嵌入到其它的工作单元中，并且对于嵌入式事务来说，嵌入的子事务即使回滚了，也不会引起外层事务的回滚。但是，如果嵌入式事务最终不能够提交的话，整个事务也将失败。可以将嵌入式事务理解成事务 树，它们存在单个根或顶级（top-level）事务，根事务是主事务。

#### 四种隔离级别
    * read uncommittted(读取未提交的内容)--(解决丢失更新，会出现脏读、不可重复读、幻读)
    * read committed(读取提交内容)--(解决丢失更新、脏读，会出现不可重复读、幻读)
    * repeatable read(可重读)--(解决丢失更新、脏读、不可重复读，会出现幻读)
    * serializable(可串行化)--(解决丢失更新、脏读、不可重复读、幻读)

##### 问题概括与分析
###### 丢失更新
    当多个事务对同一行进行更新到时候,事务之间没有感知，一个事务的操作会覆盖另一个事务的更新。    
    对行进行加锁，只允许并发一个更新事务。

###### 脏读
    一个事务读到另一个事务未提交的更新数据     

###### 不可重复读
    在同一个事务中,多次读取同一数据,返回的结果有所不同. 换句话说就是,后续读取可以读到另一个事务已提交的更新数据. 相反"可重复读"在同一事务多次读取数据时,能够保证所读数据一样,也就是后续读取不能读到另一事务已提交的更新数据.

###### 幻读
    一个事务读取到另一个事务已提交的insert数据.     
    第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时 (此时第一事务还未提交) ，第二个事务向表中插入一行新数据。这时第一个事务再去读取表时,发现表中还有没有修改的数据行，就好象发生了幻觉一样。

###### 不可重复读和幻读的区别
    很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。
    如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
    所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

## 分布式事务
> 分布式平面事务与简单平面事务（称之为本地事务）一样，如果某台机器中的某个组件放弃了事务，则整个事务都将放弃（或失败）。但是，分布式事务允许其中的单个事务跨越网络执行，并有多个不同类型的资源参与其中。

> 分布式事务处理是指一个事务可能涉及多个数据库操作，分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。

### XA
XA：是由X/Open组织提出的分布式事务的规范。XA规范主要定义了(全局)事务管理器(Transaction Manager)和(局部)资源管理器(Resource Manager)之间的接口。XA接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。XA之所以需要引入事务管理器是因为，在分布式系统中，两台机器理论上无 法达到一致的状态，需要引入一个单点进行协调。事务管理器控制着全局事务，管理事务生命周期，并协调资源。资源管理器负责控制和管理实际资源（如数据库或 JMS队列）。下图说明了事务管理器、资源管理器，与应用程序之间的关系：
![img](https://images0.cnblogs.com/blog/285763/201311/24205211-c32ce8d455664bceac19682c00c417ba.gif)
概念：
1）事务管理器。事务管理器负责协调具体的资源管理器来完成事务控制。
2）资源管理器。资源管理器具体来说就是各种驱动程序，对于数据库来说，就是具体的JDBC驱动程序。
3）事务性的资源。数据库，JMS队列，遗留系统等。

### 2PC 两阶段提交协议（Two-Phase Commit protocol）
> 所有关于分布式事务的介绍中都必然会讲到两阶段提交，因为它是实现XA分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)。所谓的两个阶段是指：第一阶段：准备阶段和第二阶段：提交阶段。

* 准备阶段：事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回 失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。(关于每一个参与者在 准备阶段具体做了什么目前我还没有参考到确切的资料，但是有一点非常确定：参与者在准备阶段完成了几乎所有正式提交的动作，有的材料上说是进行了“试探性 的提交”，只保留了最后一步耗时非常短暂的正式提交操作给第二阶段执行。)
* 提交阶段：如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)




